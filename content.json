{"meta":{"title":"Welcome to chatcent's blog","subtitle":null,"description":"个人学习记录","author":"chatcent","url":"http://yoursite.com","root":"/"},"pages":[{"title":"tags","date":"2020-03-15T07:58:32.000Z","updated":"2020-03-15T08:05:37.308Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"hcc","slug":"hcc","date":"2020-03-15T09:01:26.000Z","updated":"2020-03-15T09:01:26.325Z","comments":true,"path":"2020/03/15/hcc/","link":"","permalink":"http://yoursite.com/2020/03/15/hcc/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"C++ note","slug":"C++_note","date":"2020-02-01T02:20:37.011Z","updated":"2020-03-15T08:19:56.974Z","comments":true,"path":"2020/02/01/C++_note/","link":"","permalink":"http://yoursite.com/2020/02/01/C++_note/","excerpt":"","text":"1 endl: 结束当前行，并与设备关联的缓冲区中的内容刷新到设备中（保证所有输出真正写入到输出流中，而不是停留在内存中）。 2 注释 ：/* */不能嵌套。/*只与和它最近的*/匹配。 3 ./a.out outfile 将标准输入输出重定向为两个文件 4 实参:argument 5 浮点运算用double，数值范围超过int用long long 6 无符号类型：当赋值一个超出范围的值时，将得到该值对无符号类型表示数值总数取模后的余数（8 bit 的unsigned char表示范围：0-255，赋值-1得到 255） 7 有符号数据：当我们赋给带符号类型一个超出它表示范围的值时，结果是undefined，程序可能继续工作、可能崩溃，也可能生成垃圾数据 8 浮点数：0. .001 0e0 9 泛化的转义序列（36页） 10 赋值操作是在两个已经存在的对象间进行的，而初始化是要创建一个新的对象，并且其初值来源于另一个已存在的对象。编译器会区别这两种情况，赋值的时候调用重载的赋值运算符，初始化的时候调用拷贝构造函数。如果类中没有拷贝构造函数，则编译器会提供一个默认的。这个默认的拷贝构造函数只是简单地复制类中的每个成员。 11 列表初始化（39页） 12 未显示初始化：函数内变量默认为0，函数外则为未定义 13 引用并非对象，它是已存在的对象的别名, 一个引用不能绑定多个对象 14指针是对象，无须赋初值，若在函数外部未初始化则为未定义 123int *p = &amp;variable; int *p = nullptr/0； int *&amp;r = p; //指向指针的引用： 15 const对象创建后不能改变，必须初始化，作用范围尽在该文件内。若在多文件共享const变量，需要在定义和声明前都加上extern关键字。 16 常量引用（指针）可以绑定非常量对象，字面值，反之不可。 17 常量对象必须要用指向常量的指针。（56页） 18 constexpr只对指针有效，与指针所指的对象无关（p59） 19 类型别名不是简单的替换，需看作是一个整体（p61） 20 字符串string：直接初始化用(), 拷贝初始化用 = 21 用+连接字符串时，+号两侧必须至少有一个是string对象（从左到右运算），字面值字符串不是string对象。 22 vector（p87）：初始化过程尽可能地把{}内的值当作初始值来处理，只有当类型不对时，考虑值初始化(vactor v{10} 表示v里面有10个默认初始化的元素)。 23 凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素，否则迭代器会失效。 24 数组不允许拷贝和赋值。区别： 标准库 array允许赋值拷贝（不能用花括号列表赋值给数组，只能在声明时才可以） 25 四种强制类型转换p146 26 函数可变数量形参：当实参类型都一样时，用initiallizer_list 27 函数返回数组指针：1、使用类型别名2、 1type （*func（paras））[dimension] 28 重载函数：当形参是指针或引用，通过区分指向的是常量和非常量对象可以实现重载。 29 默认参数：一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。 30 assert（expr）：expr为假则输出信息并终止运行，反之什么也不做。 31 this指针总是指向“这个”对象，它是一个常量指针 32 class定义在第一个访问说明符之前的成员是private,struct则是public，两者定义类的唯一区别是默认的访问权限 33 友元函数声明仅仅指定了访问权限，必须再外部声明多一次，友元类可以访问private成员 34 一个const成员函数可以改变一个可变数据成员（在成员定义前加mutable关键字） 35 静态成员函数不与任何对象绑定在一起，不包含this指针，不能声明成const p269 36 类允许包含指向它自身类型的引用或指针 37 两个成员相同的类也是不同的类型 38 泛型算法不会执行容器的操作（不会改变底层容器的大小），运行于迭代器之上，执行迭代器的操作 39 lambda表达式（未命名的内联函数）： lists](paras) ->return type &#123;body&#125; 12345/*其中，paras和return type可以省略。capture lists：1、只用于局部非static变量，可以直接使用局部static和函数外的变量 2、值捕获：在创建时拷贝，而不是调用时，随后对其修改不会改变lambda内对应的值。3、引用捕获：必须保证表达式执行时变量是存在的可变lambda：当希望改变值拷贝的变量，在参数列表前加mutable关键字*/ 40 拷贝构造函数的参数必须是引用类型 41 基类的指针和引用可以绑定到派生类对象（基类的指针或引用的静态类型可能与其动态类型不一致） 42 派生类向基类的自动类型转换只对指针或引用有效，在对象之间不存在类型转换（当用一个派生类对象为一个基类对象初始化或赋值，只有基类部分的成员会被拷贝/移动/赋值，派生类部分成员被忽略） 43 当且仅当通过指针或引用调用虚函数，才会在运行时解析该调用，此时动态类型才有可能与静态类型不同。（调用非虚函数和通过对象调用函数都相同） 44 当调用了有默认实参的虚函数，该实参值由调用的静态类型决定，如果虚函数使用了默认实参，则基类和派生类的定义的虚函数默认实参最好一致。 45 派生类的成员或友元只能通过派生类对象来访问基类的protected成员。派生类对于一个基类对象的protected成员没有访问权限。 46 在以下情况下你应该使用指针，一是你考虑到存在不指向任何对象的可能（在这种情况下，你能够设置指针为空），二是你需要能够在不同的时刻指向不同的对象（在这种情况下，你能改变指针的指向）。如果总是指向一个对象并且一旦指向一个对象后就不会改变指向，那么你应该使用引用。当你重载某个操作符时，你应该使用引用 47 关键字 inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前面不起任何作用 48 一个指针或引用之索引支持多态，是因为它们并不引发内存中任何“与类型有关的内存委托操作”，会受到改变的只是它们所指向的内存的“大小和内容解释方式” 49 多态：以一个public base class 的指针，寻址出一个derived class object.定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范派生类必须实现这个函数纯虚函数的引入，是出于两个目的：1、为了安全，因为避免任何需要明确但是因为不小心而导致的未知的结果，提醒子类去做应做的实现。2、为了效率，不是程序执行的效率，而是为了编码的效率。 50 析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。","categories":[],"tags":[{"name":"note","slug":"note","permalink":"http://yoursite.com/tags/note/"}]},{"title":"state pattern","slug":"design-pattern-state-pattern","date":"2019-08-21T05:05:47.000Z","updated":"2020-03-15T08:20:33.059Z","comments":true,"path":"2019/08/21/design-pattern-state-pattern/","link":"","permalink":"http://yoursite.com/2019/08/21/design-pattern-state-pattern/","excerpt":"","text":"状态模式: 在状态模式中，类的行为是基于它的状态改变的 允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类 使用场景: 行为随状态改变而改变的场景 条件、分支语句的代替者 注意事项：在行为受状态约束的时候使用状态模式，而且状态不超过 5 个 定义各个具体状态的类 定义一个上下文类，接收每个状态类的对象 转换不同的状态，实现不同的行为 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class State(object): \"\"\"Base state. This is to share functionality\"\"\" def scan(self): \"\"\"Scan the dial to the next station\"\"\" self.pos += 1 if self.pos == len(self.stations): self.pos = 0 print(u\"Scanning... Station is %s %s\" % (self.stations[self.pos], self.name))class AmState(State): def __init__(self, radio): self.radio = radio self.stations = [\"1250\", \"1380\", \"1510\"] self.pos = 0 self.name = \"AM\" def toggle_amfm(self): print(u\"Switching to FM\") self.radio.state = self.radio.fmstateclass FmState(State): def __init__(self, radio): self.radio = radio self.stations = [\"81.3\", \"89.1\", \"103.9\"] self.pos = 0 self.name = \"FM\" def toggle_amfm(self): print(u\"Switching to AM\") self.radio.state = self.radio.amstateclass Radio(object): \"\"\"A radio. It has a scan button, and an AM/FM toggle switch.\"\"\" def __init__(self): \"\"\"We have an AM state and an FM state\"\"\" self.amstate = AmState(self) self.fmstate = FmState(self) self.state = self.amstate def toggle_amfm(self): self.state.toggle_amfm() def scan(self): self.state.scan()# Test our radio outdef main(): radio = Radio() actions = [radio.scan] * 2 + [radio.toggle_amfm] + [radio.scan] * 2 actions *= 2 for action in actions: action()if __name__ == '__main__': main() OUTPUT12345678910Scanning... Station is 1380 AMScanning... Station is 1510 AMSwitching to FMScanning... Station is 89.1 FMScanning... Station is 103.9 FMScanning... Station is 81.3 FMScanning... Station is 89.1 FMSwitching to AMScanning... Station is 1250 AMScanning... Station is 1380 AM","categories":[],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://yoursite.com/tags/design-pattern/"}]},{"title":"publish subscibe pattern","slug":"design-pattern-publish-subscibe-pattern","date":"2019-08-21T05:05:34.000Z","updated":"2020-03-15T08:20:28.068Z","comments":true,"path":"2019/08/21/design-pattern-publish-subscibe-pattern/","link":"","permalink":"http://yoursite.com/2019/08/21/design-pattern-publish-subscibe-pattern/","excerpt":"","text":"发布订阅者模式: 定义一个provider类，提供订阅消息和订阅用户与否的方法 定义一个publisher类，接收provider对象，创建一个发布消息的方法（本质是向消息数组里增加消息） 定义一个subscriber类，接收provider对象，调用订阅用户与否的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Provider: def __init__(self): self.msg_queue = [] self.subscribers = &#123;&#125; def notify(self, msg): self.msg_queue.append(msg) def subscribe(self, msg, subscriber): self.subscribers.setdefault(msg, []).append(subscriber) def unsubscribe(self, msg, subscriber): self.subscribers[msg].remove(subscriber) def update(self): for msg in self.msg_queue: for sub in self.subscribers.get(msg, []): sub.run(msg) self.msg_queue = []class Publisher: def __init__(self, msg_center): self.provider = msg_center def publish(self, msg): self.provider.notify(msg)class Subscriber: def __init__(self, name, msg_center): self.name = name self.provider = msg_center def subscribe(self, msg): self.provider.subscribe(msg, self) def unsubscribe(self, msg): self.provider.unsubscribe(msg, self) def run(self, msg): print(\"&#123;&#125; got &#123;&#125;\".format(self.name, msg))def main(): message_center = Provider() fftv = Publisher(message_center) jim = Subscriber(\"jim\", message_center) jim.subscribe(\"cartoon\") jack = Subscriber(\"jack\", message_center) jack.subscribe(\"music\") gee = Subscriber(\"gee\", message_center) gee.subscribe(\"movie\") vani = Subscriber(\"vani\", message_center) vani.subscribe(\"movie\") vani.unsubscribe(\"movie\") fftv.publish(\"cartoon\") fftv.publish(\"music\") fftv.publish(\"ads\") fftv.publish(\"movie\") fftv.publish(\"cartoon\") fftv.publish(\"cartoon\") fftv.publish(\"movie\") fftv.publish(\"blank\") message_center.update()if __name__ == \"__main__\": main() OUTPUT123456jim got cartoonjack got musicgee got moviejim got cartoonjim got cartoongee got movie","categories":[],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://yoursite.com/tags/design-pattern/"}]},{"title":"file basic operate","slug":"file-basic-operate","date":"2019-08-20T16:45:42.000Z","updated":"2019-08-20T16:58:07.448Z","comments":true,"path":"2019/08/21/file-basic-operate/","link":"","permalink":"http://yoursite.com/2019/08/21/file-basic-operate/","excerpt":"","text":"使用print()函数的输出重定向到一个文件中123#文件必须以文本打开 with open('d:/test.txt', 'wt') as f: print('Hello World!', file=f) 使用print()函数输出数据，但是想改变默认的分隔符或者行尾符123456&gt;&gt;&gt; print('ACME', 50, 91.5) ACME 50 91.5 &gt;&gt;&gt; print('ACME', 50, 91.5, sep=',') ACME,50,91.5 &gt;&gt;&gt; print('ACME', 50, 91.5, sep=',', end='!!\\n') ACME,50,91.5!! 使用操作类文件对象的程序来操作文本或二进制字符串12345678910&gt;&gt;&gt; s = io.StringIO() &gt;&gt;&gt; s.write('Hello World\\n') &gt;&gt;&gt; print('This is a test', file=s)&gt;&gt;&gt; s.getvalue() 'Hello World\\nThis is a test\\n'&gt;&gt;&gt; s = io.BytesIO() &gt;&gt;&gt; s.write(b'binary data') &gt;&gt;&gt; s.getvalue() b'binary data' 在一个固定长度记录或者数据块的集合上迭代，而不是在一个文件中一行一行的迭代文件以二进制模式打开时，通常是读取固定大小的记录,而对于文本文件，一行一行的读取(默认的迭代行为) 更普遍点。 1234567from functools import partialRECORD_SIZE = 32with open('somefile.data', 'rb') as f: records = iter(partial(f.read, RECORD_SIZE), b'') for r in records: ... 注意： records对象是一个可迭代对象，它会不断的产生固定大小的数据块，直到文件末尾。如果总记录大小不是块大小的整数倍的话，最后一个返回元素的字节数会比期望值少 iter()函数有一个鲜为人知的特性就是，如果你给它传递一个可调用对象和一个标记值，它会创建一个迭代器。这个迭代器会一直调用传入的可调用对象直到它返回标记值为止，这时候迭代终止。在例子中,functools.partial用来创建一个每次被调用时从文件中读取固定数目字节的可调用对象。标记值 b’’就是当到达文件结尾时的返回值。","categories":[],"tags":[]},{"title":"Borg pattern","slug":"design-pattern-Borg-pattern","date":"2019-08-20T07:31:45.000Z","updated":"2020-03-15T08:20:56.950Z","comments":true,"path":"2019/08/20/design-pattern-Borg-pattern/","link":"","permalink":"http://yoursite.com/2019/08/20/design-pattern-Borg-pattern/","excerpt":"","text":"Borg模式（Monostate）： 实现单例行为，某个类的多个对象共享相同的状态。 在python中，对象的属性是存在于dict中，只要在init函数中，将一个共享状态字典取代dict，就可以实现多个实例共享属性。 该模式在管理数据库连接时非常有用。 1234567891011121314151617181920212223242526272829303132333435363738class Borg(object): __shared_state = &#123;&#125; def __init__(self): self.__dict__ = self.__shared_state self.state = 'Init' def __str__(self): return self.stateclass YourBorg(Borg): passif __name__ == '__main__': rm1 = Borg() rm2 = Borg() rm1.state = 'Idle' rm2.state = 'Running' print('rm1: &#123;0&#125;'.format(rm1)) print('rm2: &#123;0&#125;'.format(rm2)) rm2.state = 'Zombie' print('rm1: &#123;0&#125;'.format(rm1)) print('rm2: &#123;0&#125;'.format(rm2)) print('rm1 id: &#123;0&#125;'.format(id(rm1))) print('rm2 id: &#123;0&#125;'.format(id(rm2))) rm3 = YourBorg() print('rm1: &#123;0&#125;'.format(rm1)) print('rm2: &#123;0&#125;'.format(rm2)) print('rm3: &#123;0&#125;'.format(rm3)) OUTPUT123456789rm1: Runningrm2: Runningrm1: Zombierm2: Zombierm1 id: 140732837899224rm2 id: 140732837899296rm1: Initrm2: Initrm3: Init","categories":[],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://yoursite.com/tags/design-pattern/"}]},{"title":"abstract factory pattern","slug":"design-pattern-abstract-factory-pattern","date":"2019-08-20T07:30:00.000Z","updated":"2020-03-15T08:21:07.189Z","comments":true,"path":"2019/08/20/design-pattern-abstract-factory-pattern/","link":"","permalink":"http://yoursite.com/2019/08/20/design-pattern-abstract-factory-pattern/","excerpt":"","text":"抽象工厂模式： 定义一个工厂类，该类的输入参数为子类的类名，在该类方法中实例化具体子类对象，并调用子类共同的方法。 最后定义各个子类并继承于工厂类，在各个子类中实现相同的方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import randomclass PetShop(object): \"\"\"A pet shop\"\"\" def __init__(self, animal_factory=None): \"\"\"pet_factory is our abstract factory. We can set it at will.\"\"\" self.pet_factory = animal_factory def show_pet(self): \"\"\"Creates and shows a pet using the abstract factory\"\"\" pet = self.pet_factory() print(\"We have a lovely &#123;&#125;\".format(pet)) print(\"It says &#123;&#125;\".format(pet.speak()))class Dog(object): def speak(self): return \"woof\" def __str__(self): return \"Dog\"class Cat(object): def speak(self): return \"meow\" def __str__(self): return \"Cat\"# Additional factories:# Create a random animaldef random_animal(): \"\"\"Let's be dynamic!\"\"\" return random.choice([Dog, Cat])()# Show pets with various factoriesif __name__ == \"__main__\": # A Shop that sells only cats cat_shop = PetShop(Cat) cat_shop.show_pet() print(\"\") # A shop that sells random animals shop = PetShop(random_animal) for i in range(3): shop.show_pet() print(\"=\" * 20) OUTPUT1234567891011We have a lovely CatIt says meowWe have a lovely DogIt says woofWe have a lovely CatIt says meowWe have a lovely CatIt says meow","categories":[],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://yoursite.com/tags/design-pattern/"}]},{"title":"markdown note","slug":"markdown-note","date":"2019-08-19T11:17:09.378Z","updated":"2020-03-15T08:21:32.110Z","comments":true,"path":"2019/08/19/markdown-note/","link":"","permalink":"http://yoursite.com/2019/08/19/markdown-note/","excerpt":"","text":"多个空格只显示一个空格 单纯回车则连续 （全角符号下多空格有效，可实现首行缩进）斜体字体（两个空格加回车）粗体字体粗斜体字体**反斜号转义** 以下是分割线，三个符号以上，中间可加空格，但行内不能有文字 删除线 有序列表 数字加.表示1.2.3. 列表嵌套 子列表前加四个空格 一 *一点一 *一点二 二 +二点一 +二点二 区块 &gt;加空格 你好你们好 区块嵌套 你好 你们好 12def func(): pass 链接两种表示 [名称]（网址）或者 &lt;网址&gt;my bloghttpps://chatcent.github,io 链接变量 [名称][变量]my blog 图片表示：![图片名称]（图片地址）表格：|分隔单元格，-分隔表头和其他行 左对齐:- 右对齐-：居中:-:（看冒号位置） 表头 表头 单元格 单元格 单元格 单元格 左对齐 右对齐 居中 单元格 单元格 单元格 单元格 单元格 单元格 文字加方框：前面加四个空格加方框的文字无序列表 用* + - 表示*第一项*第二项*第三项","categories":[],"tags":[{"name":"note","slug":"note","permalink":"http://yoursite.com/tags/note/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-08-14T05:33:42.409Z","updated":"2019-08-14T05:33:42.409Z","comments":true,"path":"2019/08/14/hello-world/","link":"","permalink":"http://yoursite.com/2019/08/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}